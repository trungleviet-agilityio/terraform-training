#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
OUT_DIR="$ROOT_DIR/../out"

print() { echo "[cb] $*"; }
error() { echo "[cb][error] $*" >&2; }

show_help() {
  cat <<'EOF'
Usage: cb <command> [options]

Commands:
  build              Build Lambda artifacts (zip mode)
    --api-dir DIR      Path to API sources (default: practice/app/api)
    --layer-dir DIR    Path to Layer sources (default: practice/app/layer)

  deploy             Deploy Terraform for an environment
    --env ENV          dev|stage|prod (default: dev)
    --app              Apply only (no build)

  help               Show this help

Environment for deploy backend:
  AWS_REGION, TF_STATE_BUCKET, TF_LOCK_TABLE
  State key will be: practice/<env>/terraform.tfstate
EOF
}

cmd_build() {
  local api_dir="$ROOT_DIR/../practice/app/api"
  local layer_dir="$ROOT_DIR/../practice/app/layer"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --api-dir) api_dir="$2"; shift 2;;
      --layer-dir) layer_dir="$2"; shift 2;;
      *) error "Unknown build option: $1"; exit 1;;
    esac
  done

  mkdir -p "$OUT_DIR"

  # Build layer.zip if layer sources exist
  if [[ -d "$layer_dir" ]]; then
    print "Packaging layer from $layer_dir"
    (cd "$layer_dir" && zip -r "$OUT_DIR/layer.zip" . -x "**/__pycache__/*" "**/*.pyc" >/dev/null)
  else
    print "Layer dir not found ($layer_dir); skipping layer.zip"
  fi

  # Build function.zip if api sources exist
  if [[ -d "$api_dir" ]]; then
    print "Packaging function from $api_dir"
    (cd "$api_dir" && zip -r "$OUT_DIR/function.zip" . -x "**/__pycache__/*" "**/*.pyc" >/dev/null)
  else
    print "API dir not found ($api_dir); skipping function.zip"
  fi

  print "Artifacts in $OUT_DIR"
}

cmd_deploy() {
  local env_name="dev"
  local app_only=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --env) env_name="$2"; shift 2;;
      --app) app_only=true; shift;;
      *) error "Unknown deploy option: $1"; exit 1;;
    esac
  done

  local env_path="$ROOT_DIR/../practice/envs/$env_name"
  if [[ ! -d "$env_path" ]]; then
    error "Environment path not found: $env_path"; exit 1
  fi

  if [[ "$app_only" == false ]]; then
    cmd_build || true
  else
    print "--app specified: skipping build"
  fi

  : "${AWS_REGION:?Set AWS_REGION}"
  : "${TF_STATE_BUCKET:?Set TF_STATE_BUCKET}"
  : "${TF_LOCK_TABLE:?Set TF_LOCK_TABLE}"

  print "Deploying $env_name from $env_path"
  (
    cd "$env_path"
    terraform init \
      -backend-config="bucket=$TF_STATE_BUCKET" \
      -backend-config="dynamodb_table=$TF_LOCK_TABLE" \
      -backend-config="key=practice/$env_name/terraform.tfstate" \
      -backend-config="region=$AWS_REGION"
    terraform apply -auto-approve
  )
}

main() {
  case "${1:-help}" in
    help|--help|-h) show_help ;;
    build) shift; cmd_build "$@" ;;
    deploy) shift; cmd_deploy "$@" ;;
    test) print "Test pipeline to be implemented" ;;
    *) error "Unknown command: ${1:-}"; echo; show_help; exit 1 ;;
  esac
}

main "$@"
